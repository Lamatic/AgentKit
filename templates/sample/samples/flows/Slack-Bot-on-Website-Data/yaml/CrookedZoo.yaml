triggerNode:
  nodeId: triggerNode_1
  nodeType: graphqlNode
  nodeName: API Request
  values:
    responeType: realtime
    advance_schema: |-
      {
        "urls": "[string]"
      }
  modes: {}
  allConfigs:
    Config A:
      nodeName: API Request
      responeType: realtime
      advance_schema: |-
        {
          "urls": "[string]"
        }
  schema:
    sampleOutput: string
nodes:
  - nodeId: sticky-note-609
    nodeType: stickyNoteNode
    nodeName: Sticky Note
    values:
      text: >-
        # **âš¡ï¸ Flow Trigger**


        ---


        _A trigger initiates the flow. It can be a built-in tool or an
        integration with an external application._


        Trigger Types:


        1. **ðŸ“±App** \- Initiate flow from an external application integration

        2. **ðŸ”Œ Interface** \- API / Webhook

        3. **ðŸ’¬ Widget** \- Prebuilt UI component ( Chat, Search )


        ---


        ðŸ“– Read Docs - [Flows](https://lamatic.ai/docs/flows)
      color: purple
      nodeId: stickyNoteNode
      nodeType: stickyNoteNode
    modes: {}
    needs: []
    allConfigs:
      Config A:
        id: sticky-note-609
        text: >-
          # **âš¡ï¸ Flow Trigger**


          ---


          _A trigger initiates the flow. It can be a built-in tool or an
          integration with an external application._


          Trigger Types:


          1. **ðŸ“±App** \- Initiate flow from an external application integration

          2. **ðŸ”Œ Interface** \- API / Webhook

          3. **ðŸ’¬ Widget** \- Prebuilt UI component ( Chat, Search )


          ---


          ðŸ“– Read Docs - [Flows](https://lamatic.ai/docs/flows)
        color: purple
        nodeId: stickyNoteNode
        nodeName: Sticky Note
        nodeType: stickyNoteNode
    position:
      x: -846.0854460055239
      'y': -9.156120915628719
    measured:
      width: 691
      height: 250
  - nodeId: sticky-qnyx8cr1s
    nodeType: stickyNoteNode
    nodeName: Sticky Note
    values:
      text: >-
        # **â–¶ï¸ Try it out**


        1. **Trigger via GraphQL / API**  

        \_This flow is initiated using an API request. Pass an array of URLs to
        begin processing:  

        ```json  

        {  

        "urls": ["https://example.com/page1", "https://example.com/page2"]  

        }  

        ```

        2. **ðŸ” Firecrawl Node**  

        _Scrapes and extracts main content from all provided URLs._  

        You can control crawling depth, timeouts, and exclusion filters.

        3. **ðŸ” Loop + Chunking**  

        _Each pageâ€™s content is chunked into smaller sections for better
        embedding._  

        Chunks are extracted and processed sequentially in a loop.

        4. **ðŸ§  Vectorization**  

        _Each chunk is converted into a vector using your configured embedding
        model._

        5. **ðŸ—‚ï¸ Index to Vector DB**  

        _Vectors and their metadata (title, description, source) are stored in
        your selected database._


        # **â–¶ï¸ Test it ðŸ‘‡ðŸ»**


        **Option A:** Run directly using the GraphQL API trigger  

        **Option B:** Test via the in-app â€œRun Flowâ€ button


        _Once done, check your Vector DB to confirm that all records were
        indexed successfully!_
      color: yellow
      nodeId: stickyNoteNode
      nodeType: stickyNoteNode
    modes: {}
    needs: []
    allConfigs:
      Config A:
        id: sticky-qnyx8cr1s
        text: >-
          # **â–¶ï¸ Try it out**


          1. **Trigger via GraphQL / API**  

          \_This flow is initiated using an API request. Pass an array of URLs
          to begin processing:  

          ```json  

          {  

          "urls": ["https://example.com/page1", "https://example.com/page2"]  

          }  

          ```

          2. **ðŸ” Firecrawl Node**  

          _Scrapes and extracts main content from all provided URLs._  

          You can control crawling depth, timeouts, and exclusion filters.

          3. **ðŸ” Loop + Chunking**  

          _Each pageâ€™s content is chunked into smaller sections for better
          embedding._  

          Chunks are extracted and processed sequentially in a loop.

          4. **ðŸ§  Vectorization**  

          _Each chunk is converted into a vector using your configured embedding
          model._

          5. **ðŸ—‚ï¸ Index to Vector DB**  

          _Vectors and their metadata (title, description, source) are stored in
          your selected database._


          # **â–¶ï¸ Test it ðŸ‘‡ðŸ»**


          **Option A:** Run directly using the GraphQL API trigger  

          **Option B:** Test via the in-app â€œRun Flowâ€ button


          _Once done, check your Vector DB to confirm that all records were
          indexed successfully!_
        color: yellow
        nodeId: stickyNoteNode
        nodeName: Sticky Note
        nodeType: stickyNoteNode
    position:
      x: -1466.406867821386
      'y': 284.2903797711152
    measured:
      width: 610
      height: 878
  - nodeId: sticky-kzv63mb30
    nodeType: stickyNoteNode
    nodeName: Sticky Note
    values:
      text: >-
        # **ðŸ’¬ Flow response**


        ---


        ## _The final step of your flow can send output to an external system,
        which is particularly useful for flows initiated by triggers like Chat
        or GraphQL API integrations._
      color: green
      nodeId: stickyNoteNode
      nodeType: stickyNoteNode
    modes: {}
    needs: []
    allConfigs:
      Config A:
        id: sticky-kzv63mb30
        text: >-
          # **ðŸ’¬ Flow response**


          ---


          ## _The final step of your flow can send output to an external system,
          which is particularly useful for flows initiated by triggers like Chat
          or GraphQL API integrations._
        color: green
        nodeId: stickyNoteNode
        nodeName: Sticky Note
        nodeType: stickyNoteNode
    position:
      x: -857.0805062057627
      'y': 1193.344780096305
    measured:
      width: 689
      height: 185
  - nodeId: sticky-gm21yx26f
    nodeType: stickyNoteNode
    nodeName: Sticky Note
    values:
      text: >-
        # **âž• Nodes**


        ---


        _Nodes are the fundamental building blocks of a flow. Each node serves a
        specific purpose, acting as a self-contained unit that processes input
        and produces output. This modular approach allows users to create
        complex flows by interconnecting various nodes._


        Node Types :


        1. **ðŸ“± Apps** \- Integrate third-party applications into your flow.

        2. **ðŸ¤– AI** \- Perform AI operations within your flow.

        3. **ðŸ›¢ï¸ Data** \- Manipulate and transform data within your flow.

        4. **â™¾ï¸ Logic** \- Control the flow of execution in your flow.
      color: blue
      nodeId: stickyNoteNode
      nodeType: stickyNoteNode
    modes: {}
    needs: []
    allConfigs:
      Config A:
        id: sticky-gm21yx26f
        text: >-
          # **âž• Nodes**


          ---


          _Nodes are the fundamental building blocks of a flow. Each node serves
          a specific purpose, acting as a self-contained unit that processes
          input and produces output. This modular approach allows users to
          create complex flows by interconnecting various nodes._


          Node Types :


          1. **ðŸ“± Apps** \- Integrate third-party applications into your flow.

          2. **ðŸ¤– AI** \- Perform AI operations within your flow.

          3. **ðŸ›¢ï¸ Data** \- Manipulate and transform data within your flow.

          4. **â™¾ï¸ Logic** \- Control the flow of execution in your flow.
        color: blue
        nodeId: stickyNoteNode
        nodeName: Sticky Note
        nodeType: stickyNoteNode
    position:
      x: -847.0386648188429
      'y': 280.92513207360435
    measured:
      width: 683
      height: 889
  - nodeId: firecrawlNode_785
    nodeType: firecrawlNode
    nodeName: Firecrawl
    values:
      url: ''
      mode: syncBatchScrape
      urls: '{{triggerNode_1.output.urls}}'
      delay: 0
      limit: 10
      mobile: false
      search: ''
      timeout: 30000
      waitFor: 2000
      crawlDepth: 1
      crawlLimit: 10
      credentials: FIRECRAWL_API_KEY
      excludePath: &ref_0 []
      excludeTags: &ref_1 []
      includePath: &ref_2 []
      includeTags: &ref_3 []
      sitemapOnly: false
      crawlSubPages: false
      ignoreSitemap: false
      webhookEvents: &ref_4
        - completed
        - failed
        - page
        - started
      changeTracking: false
      webhookHeaders: ''
      onlyMainContent: true
      webhookMetadata: ''
      includeSubdomains: false
      maxDiscoveryDepth: 1
      allowBackwardLinks: false
      allowExternalLinks: false
      skipTlsVerification: false
      ignoreQueryParameters: true
    modes:
      webhook: list
    needs:
      - triggerNode_1
    allConfigs:
      Config A:
        id: firecrawlNode_785
        url: ''
        mode: syncBatchScrape
        urls: '{{triggerNode_1.output.urls}}'
        delay: 0
        limit: 10
        mobile: false
        search: ''
        timeout: 30000
        waitFor: 2000
        nodeName: Firecrawl
        crawlDepth: 1
        crawlLimit: 10
        credentials: FIRECRAWL_API_KEY
        excludePath: *ref_0
        excludeTags: *ref_1
        includePath: *ref_2
        includeTags: *ref_3
        sitemapOnly: false
        crawlSubPages: false
        ignoreSitemap: false
        webhookEvents: *ref_4
        changeTracking: false
        webhookHeaders: ''
        onlyMainContent: true
        webhookMetadata: ''
        includeSubdomains: false
        maxDiscoveryDepth: 1
        allowBackwardLinks: false
        allowExternalLinks: false
        skipTlsVerification: false
        ignoreQueryParameters: true
    schema:
      data: array
      total: number
      status: string
      success: boolean
      completed: string
      expiresAt: string
      creditsUsed: number
    logic: []
  - nodeId: forLoopNode_370
    nodeType: forLoopNode
    nodeName: Loop
    values:
      wait: 0
      endValue: '10'
      increment: '1'
      connectedTo: forLoopEndNode_301
      iterateOver: list
      initialValue: '0'
      iteratorValue: '{{firecrawlNode_785.output.data}}'
    modes: {}
    needs:
      - firecrawlNode_785
      - forLoopEndNode_301
    allConfigs:
      Config A:
        wait: 0
        endValue: '10'
        nodeName: Loop
        increment: '1'
        connectedTo: forLoopEndNode_301
        iterateOver: list
        initialValue: '0'
        iteratorValue: '{{firecrawlNode_785.output.data}}'
    schema:
      currentValue: object
    connections:
      - condition: Loop Start
        value: variablesNode_658
        type: conditionEdge
        invisible: true
      - condition: Loop
        value: forLoopEndNode_301
        type: loopEdge
        invisible: false
  - nodeId: variablesNode_658
    nodeType: variablesNode
    nodeName: Variables
    values:
      mapping: |-
        {
          "title": {
            "type": "string",
            "value": "{{forLoopNode_370.output.currentValue.metadata.title}}"
          },
          "description": {
            "type": "string",
            "value": "{{forLoopNode_370.output.currentValue.metadata.description}}"
          },
          "source": {
            "type": "string",
            "value": "{{forLoopNode_370.output.currentValue.metadata.url}}"
          }
        }
    modes: {}
    needs:
      - forLoopNode_370
    allConfigs:
      Config A:
        mapping: |-
          {
            "title": {
              "type": "string",
              "value": "{{forLoopNode_370.output.currentValue.metadata.title}}"
            },
            "description": {
              "type": "string",
              "value": "{{forLoopNode_370.output.currentValue.metadata.description}}"
            },
            "source": {
              "type": "string",
              "value": "{{forLoopNode_370.output.currentValue.metadata.url}}"
            }
          }
        nodeName: Variables
    schema: {}
  - nodeId: chunkNode_968
    nodeType: chunkNode
    nodeName: Chunking
    values:
      chunkField: '{{forLoopNode_370.output.currentValue.markdown}}'
      numOfChars: 500
      separators: &ref_5
        - |+


        - |+

        - ' '
      chunkingType: recursiveCharacterTextSplitter
      overlapChars: 50
    modes: {}
    needs:
      - variablesNode_658
    allConfigs:
      Config A:
        nodeName: Chunking
        chunkField: '{{forLoopNode_370.output.currentValue.markdown}}'
        numOfChars: 500
        separators: *ref_5
        chunkingType: recursiveCharacterTextSplitter
        overlapChars: 50
    schema:
      chunks: string
  - nodeId: codeNode_794
    nodeType: codeNode
    nodeName: Extract Chunks
    values:
      code: |-
        let docs = {{ chunkNode_968.output.chunks }};

        let outputDocs = docs.map((doc) => doc.pageContent)

        return outputDocs
    modes: {}
    needs:
      - chunkNode_968
    allConfigs:
      Config A:
        code: |-
          let docs = {{ chunkNode_968.output.chunks }};

          let outputDocs = docs.map((doc) => doc.pageContent)

          return outputDocs
        nodeName: Extract Chunks
    schema: {}
  - nodeId: vectorizeNode_314
    nodeType: vectorizeNode
    nodeName: Vectorize
    values:
      inputText: '{{codeNode_794.output}}'
      embeddingModelName: &ref_6
        type: embedder/text
        params: {}
        model_name: text-embedding-ada-002
        credentialId: 0fc2f9ae-4a22-41e3-b63a-3e7db8902a9e
        provider_name: openai
        credential_name: OPENAI_KEY
    modes: {}
    needs:
      - codeNode_794
    allConfigs:
      Config A:
        id: vectorizeNode_314
        nodeName: Vectorize
        inputText: '{{codeNode_794.output}}'
        embeddingModelName: *ref_6
    schema:
      _meta: object
      vectors: object
    logic: []
  - nodeId: codeNode_305
    nodeType: codeNode
    nodeName: Transform Metadata
    values:
      code: |-
        let vectors = {{ vectorizeNode_314.output.vectors }};
        let metadataProps = [];
        let texts = {{codeNode_794.output}};

        for (const idx in vectors) {
          let metadata = {}
          metadata["content"] = texts[idx];
          metadata["title"] = {{variablesNode_658.output.title}};
          metadata["description"] = {{variablesNode_658.output.description}};
          metadata["source"] = {{variablesNode_658.output.source}};
          metadataProps.push(metadata)
        };

        output = { "metadata": metadataProps, "vectors": vectors }
    modes: {}
    needs:
      - vectorizeNode_314
    allConfigs:
      Config A:
        code: |-
          let vectors = {{ vectorizeNode_314.output.vectors }};
          let metadataProps = [];
          let texts = {{codeNode_794.output}};

          for (const idx in vectors) {
            let metadata = {}
            metadata["content"] = texts[idx];
            metadata["title"] = {{variablesNode_658.output.title}};
            metadata["description"] = {{variablesNode_658.output.description}};
            metadata["source"] = {{variablesNode_658.output.source}};
            metadataProps.push(metadata)
          };

          output = { "metadata": metadataProps, "vectors": vectors }
        nodeName: Transform Metadata
    schema: {}
  - nodeId: vectorNode_157
    nodeType: vectorNode
    nodeName: Index
    values:
      limit: 20
      action: index
      filters: ''
      vectorDB: TestDB
      primaryKeys: &ref_7
        - title
      vectorsField: '{{codeNode_305.output.vectors}}'
      metadataField: '{{codeNode_305.output.metadata}}'
      duplicateOperation: overwrite
    modes: {}
    needs:
      - codeNode_305
    allConfigs:
      Config A:
        id: vectorNode_157
        limit: 20
        action: index
        filters: ''
        nodeName: Index
        vectorDB: TestDB
        primaryKeys: *ref_7
        vectorsField: '{{codeNode_305.output.vectors}}'
        metadataField: '{{codeNode_305.output.metadata}}'
        duplicateOperation: overwrite
    schema:
      message: string
      recordsIndexed: string
      duplicateRecordsDeleted: string
    logic: []
  - nodeId: forLoopEndNode_301
    nodeType: forLoopEndNode
    nodeName: Loop End
    values:
      connectedTo: forLoopNode_370
    modes: {}
    needs:
      - vectorNode_157
      - forLoopNode_370
    allConfigs:
      Config A:
        nodeName: Loop End
        connectedTo: forLoopNode_370
    schema:
      loopOutput: object
    connections:
      - condition: Loop
        value: forLoopNode_370
        type: loopEdge
        invisible: true
responseNode:
  nodeId: graphqlResponseNode_532
  nodeType: graphqlResponseNode
  nodeName: API Response
  values:
    outputMapping: |-
      {
        "output": "Records indexed successfully"
      }
  needs:
    - forLoopEndNode_301
  modes: {}
  allConfigs:
    Config A:
      nodeName: API Response
      outputMapping: |-
        {
          "output": "Records indexed successfully"
        }
  logic: []
  schema: {}